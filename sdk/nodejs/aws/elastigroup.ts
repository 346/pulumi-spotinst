// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

export class Elastigroup extends pulumi.CustomResource {
    /**
     * Get an existing Elastigroup resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: ElastigroupState, opts?: pulumi.CustomResourceOptions): Elastigroup {
        return new Elastigroup(name, <any>state, { ...opts, id: id });
    }

    public readonly availabilityZones: pulumi.Output<string[] | undefined>;
    public readonly blockDevicesMode: pulumi.Output<string | undefined>;
    public readonly capacityUnit: pulumi.Output<string>;
    public readonly cpuCredits: pulumi.Output<string | undefined>;
    public readonly description: pulumi.Output<string | undefined>;
    public readonly desiredCapacity: pulumi.Output<number | undefined>;
    public readonly drainingTimeout: pulumi.Output<number | undefined>;
    public readonly ebsBlockDevices: pulumi.Output<{ deleteOnTermination: boolean, deviceName: string, encrypted: boolean, iops?: number, kmsKeyId?: string, snapshotId?: string, volumeSize?: number, volumeType: string }[] | undefined>;
    public readonly ebsOptimized: pulumi.Output<boolean>;
    public readonly elasticIps: pulumi.Output<string[] | undefined>;
    public readonly elasticLoadBalancers: pulumi.Output<string[] | undefined>;
    public readonly enableMonitoring: pulumi.Output<boolean | undefined>;
    public readonly ephemeralBlockDevices: pulumi.Output<{ deviceName: string, virtualName: string }[] | undefined>;
    public readonly fallbackToOndemand: pulumi.Output<boolean>;
    public readonly healthCheckGracePeriod: pulumi.Output<number | undefined>;
    public readonly healthCheckType: pulumi.Output<string | undefined>;
    public readonly healthCheckUnhealthyDurationBeforeReplacement: pulumi.Output<number | undefined>;
    public readonly iamInstanceProfile: pulumi.Output<string | undefined>;
    public readonly imageId: pulumi.Output<string | undefined>;
    public readonly instanceTypesOndemand: pulumi.Output<string>;
    public readonly instanceTypesPreferredSpots: pulumi.Output<string[] | undefined>;
    public readonly instanceTypesSpots: pulumi.Output<string[]>;
    public readonly instanceTypesWeights: pulumi.Output<{ instanceType: string, weight: number }[] | undefined>;
    public readonly integrationBeanstalk: pulumi.Output<{ deploymentPreferences?: { automaticRoll?: boolean, batchSizePercentage?: number, gracePeriod?: number, strategy?: { action?: string, shouldDrainInstances?: boolean } }, environmentId?: string, managedActions?: { platformUpdate?: { performAt?: string, timeWindow?: string, updateLevel?: string } } } | undefined>;
    public readonly integrationCodedeploy: pulumi.Output<{ cleanupOnFailure: boolean, deploymentGroups: { applicationName: string, deploymentGroupName: string }[], terminateInstanceOnFailure: boolean } | undefined>;
    public readonly integrationDockerSwarm: pulumi.Output<{ autoscaleCooldown?: number, autoscaleDown?: { evaluationPeriods?: number }, autoscaleHeadroom?: { cpuPerUnit?: number, memoryPerUnit?: number, numOfUnits?: number }, autoscaleIsEnabled?: boolean, masterHost: string, masterPort: number } | undefined>;
    public readonly integrationEcs: pulumi.Output<{ autoscaleAttributes?: { key: string, value: string }[], autoscaleCooldown?: number, autoscaleDown?: { evaluationPeriods?: number }, autoscaleHeadroom?: { cpuPerUnit?: number, memoryPerUnit?: number, numOfUnits?: number }, autoscaleIsAutoConfig?: boolean, autoscaleIsEnabled?: boolean, autoscaleScaleDownNonServiceTasks?: boolean, clusterName: string } | undefined>;
    public readonly integrationGitlab: pulumi.Output<{ runner?: { isEnabled?: boolean } } | undefined>;
    public readonly integrationKubernetes: pulumi.Output<{ apiServer?: string, autoscaleCooldown?: number, autoscaleDown?: { evaluationPeriods?: number }, autoscaleHeadroom?: { cpuPerUnit?: number, memoryPerUnit?: number, numOfUnits?: number }, autoscaleIsAutoConfig?: boolean, autoscaleIsEnabled?: boolean, autoscaleLabels?: { key: string, value: string }[], clusterIdentifier?: string, integrationMode?: string, token?: string } | undefined>;
    public readonly integrationMesosphere: pulumi.Output<{ apiServer: string } | undefined>;
    public readonly integrationMultaiRuntime: pulumi.Output<{ deploymentId: string } | undefined>;
    public readonly integrationNomad: pulumi.Output<{ aclToken?: string, autoscaleConstraints?: { key: string, value: string }[], autoscaleCooldown?: number, autoscaleDown?: { evaluationPeriods?: number }, autoscaleHeadroom?: { cpuPerUnit?: number, memoryPerUnit?: number, numOfUnits?: number }, autoscaleIsEnabled?: boolean, masterHost: string, masterPort: number } | undefined>;
    public readonly integrationRancher: pulumi.Output<{ accessKey: string, masterHost: string, secretKey: string, version?: string } | undefined>;
    public readonly integrationRoute53: pulumi.Output<{ domains: { hostedZoneId: string, recordSets: { name: string, usePublicIp?: boolean }[] }[] } | undefined>;
    public readonly keyName: pulumi.Output<string | undefined>;
    public readonly lifetimePeriod: pulumi.Output<string | undefined>;
    public readonly maxSize: pulumi.Output<number>;
    public readonly minSize: pulumi.Output<number>;
    public readonly multaiTargetSets: pulumi.Output<{ balancerId: string, targetSetId: string }[] | undefined>;
    public readonly name: pulumi.Output<string>;
    public readonly networkInterfaces: pulumi.Output<{ associateIpv6Address?: boolean, associatePublicIpAddress?: boolean, deleteOnTermination: boolean, description?: string, deviceIndex: string, networkInterfaceId?: string, privateIpAddress?: string, secondaryPrivateIpAddressCount?: string }[] | undefined>;
    public readonly ondemandCount: pulumi.Output<number | undefined>;
    public readonly orientation: pulumi.Output<string>;
    public readonly persistBlockDevices: pulumi.Output<boolean | undefined>;
    public readonly persistPrivateIp: pulumi.Output<boolean | undefined>;
    public readonly persistRootDevice: pulumi.Output<boolean | undefined>;
    public readonly placementTenancy: pulumi.Output<string | undefined>;
    public readonly preferredAvailabilityZones: pulumi.Output<string[] | undefined>;
    public readonly privateIps: pulumi.Output<string[] | undefined>;
    public readonly product: pulumi.Output<string>;
    public readonly region: pulumi.Output<string | undefined>;
    public readonly revertToSpot: pulumi.Output<{ performAt: string, timeWindows?: string[] } | undefined>;
    public readonly scalingDownPolicies: pulumi.Output<{ actionType?: string, adjustment?: string, cooldown: number, dimensions?: {[key: string]: any}, evaluationPeriods: number, isEnabled?: boolean, maxTargetCapacity?: string, maximum?: string, metricName: string, minTargetCapacity?: string, minimum?: string, namespace: string, operator: string, period: number, policyName: string, source: string, statistic: string, target?: string, threshold: number, unit: string }[] | undefined>;
    public readonly scalingTargetPolicies: pulumi.Output<{ cooldown: number, dimensions?: {[key: string]: any}, metricName: string, namespace: string, policyName: string, source: string, statistic: string, target: number, unit: string }[] | undefined>;
    public readonly scalingUpPolicies: pulumi.Output<{ actionType?: string, adjustment?: string, cooldown: number, dimensions?: {[key: string]: any}, evaluationPeriods: number, isEnabled?: boolean, maxTargetCapacity?: string, maximum?: string, metricName: string, minTargetCapacity?: string, minimum?: string, namespace: string, operator: string, period: number, policyName: string, source: string, statistic: string, target?: string, threshold: number, unit: string }[] | undefined>;
    public readonly scheduledTasks: pulumi.Output<{ adjustment?: string, adjustmentPercentage?: string, batchSizePercentage?: string, cronExpression?: string, frequency?: string, gracePeriod?: string, isEnabled?: boolean, maxCapacity?: string, minCapacity?: string, scaleMaxCapacity?: string, scaleMinCapacity?: string, scaleTargetCapacity?: string, startTime?: string, targetCapacity?: string, taskType: string }[] | undefined>;
    public readonly securityGroups: pulumi.Output<string[]>;
    public readonly shutdownScript: pulumi.Output<string | undefined>;
    public readonly signals: pulumi.Output<{ name: string, timeout?: number }[] | undefined>;
    public readonly spotPercentage: pulumi.Output<number | undefined>;
    public readonly statefulDeallocation: pulumi.Output<{ shouldDeleteImages?: boolean, shouldDeleteNetworkInterfaces?: boolean, shouldDeleteSnapshots?: boolean, shouldDeleteVolumes?: boolean } | undefined>;
    public readonly subnetIds: pulumi.Output<string[] | undefined>;
    public readonly tags: pulumi.Output<{ key: string, value: string }[] | undefined>;
    public readonly targetGroupArns: pulumi.Output<string[] | undefined>;
    public readonly updatePolicy: pulumi.Output<{ autoApplyTags?: boolean, rollConfig?: { batchSizePercentage: number, gracePeriod?: number, healthCheckType?: string, waitForRollPercentage?: number, waitForRollTimeout?: number }, shouldResumeStateful: boolean, shouldRoll: boolean, waitForRollPercentage?: number, waitForRollTimeout?: number } | undefined>;
    public readonly userData: pulumi.Output<string | undefined>;
    public readonly utilizeReservedInstances: pulumi.Output<boolean | undefined>;
    public readonly waitForCapacity: pulumi.Output<number | undefined>;
    public readonly waitForCapacityTimeout: pulumi.Output<number | undefined>;

    /**
     * Create a Elastigroup resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ElastigroupArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: ElastigroupArgs | ElastigroupState, opts?: pulumi.CustomResourceOptions) {
        let inputs: pulumi.Inputs = {};
        if (opts && opts.id) {
            const state: ElastigroupState = argsOrState as ElastigroupState | undefined;
            inputs["availabilityZones"] = state ? state.availabilityZones : undefined;
            inputs["blockDevicesMode"] = state ? state.blockDevicesMode : undefined;
            inputs["capacityUnit"] = state ? state.capacityUnit : undefined;
            inputs["cpuCredits"] = state ? state.cpuCredits : undefined;
            inputs["description"] = state ? state.description : undefined;
            inputs["desiredCapacity"] = state ? state.desiredCapacity : undefined;
            inputs["drainingTimeout"] = state ? state.drainingTimeout : undefined;
            inputs["ebsBlockDevices"] = state ? state.ebsBlockDevices : undefined;
            inputs["ebsOptimized"] = state ? state.ebsOptimized : undefined;
            inputs["elasticIps"] = state ? state.elasticIps : undefined;
            inputs["elasticLoadBalancers"] = state ? state.elasticLoadBalancers : undefined;
            inputs["enableMonitoring"] = state ? state.enableMonitoring : undefined;
            inputs["ephemeralBlockDevices"] = state ? state.ephemeralBlockDevices : undefined;
            inputs["fallbackToOndemand"] = state ? state.fallbackToOndemand : undefined;
            inputs["healthCheckGracePeriod"] = state ? state.healthCheckGracePeriod : undefined;
            inputs["healthCheckType"] = state ? state.healthCheckType : undefined;
            inputs["healthCheckUnhealthyDurationBeforeReplacement"] = state ? state.healthCheckUnhealthyDurationBeforeReplacement : undefined;
            inputs["iamInstanceProfile"] = state ? state.iamInstanceProfile : undefined;
            inputs["imageId"] = state ? state.imageId : undefined;
            inputs["instanceTypesOndemand"] = state ? state.instanceTypesOndemand : undefined;
            inputs["instanceTypesPreferredSpots"] = state ? state.instanceTypesPreferredSpots : undefined;
            inputs["instanceTypesSpots"] = state ? state.instanceTypesSpots : undefined;
            inputs["instanceTypesWeights"] = state ? state.instanceTypesWeights : undefined;
            inputs["integrationBeanstalk"] = state ? state.integrationBeanstalk : undefined;
            inputs["integrationCodedeploy"] = state ? state.integrationCodedeploy : undefined;
            inputs["integrationDockerSwarm"] = state ? state.integrationDockerSwarm : undefined;
            inputs["integrationEcs"] = state ? state.integrationEcs : undefined;
            inputs["integrationGitlab"] = state ? state.integrationGitlab : undefined;
            inputs["integrationKubernetes"] = state ? state.integrationKubernetes : undefined;
            inputs["integrationMesosphere"] = state ? state.integrationMesosphere : undefined;
            inputs["integrationMultaiRuntime"] = state ? state.integrationMultaiRuntime : undefined;
            inputs["integrationNomad"] = state ? state.integrationNomad : undefined;
            inputs["integrationRancher"] = state ? state.integrationRancher : undefined;
            inputs["integrationRoute53"] = state ? state.integrationRoute53 : undefined;
            inputs["keyName"] = state ? state.keyName : undefined;
            inputs["lifetimePeriod"] = state ? state.lifetimePeriod : undefined;
            inputs["maxSize"] = state ? state.maxSize : undefined;
            inputs["minSize"] = state ? state.minSize : undefined;
            inputs["multaiTargetSets"] = state ? state.multaiTargetSets : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["networkInterfaces"] = state ? state.networkInterfaces : undefined;
            inputs["ondemandCount"] = state ? state.ondemandCount : undefined;
            inputs["orientation"] = state ? state.orientation : undefined;
            inputs["persistBlockDevices"] = state ? state.persistBlockDevices : undefined;
            inputs["persistPrivateIp"] = state ? state.persistPrivateIp : undefined;
            inputs["persistRootDevice"] = state ? state.persistRootDevice : undefined;
            inputs["placementTenancy"] = state ? state.placementTenancy : undefined;
            inputs["preferredAvailabilityZones"] = state ? state.preferredAvailabilityZones : undefined;
            inputs["privateIps"] = state ? state.privateIps : undefined;
            inputs["product"] = state ? state.product : undefined;
            inputs["region"] = state ? state.region : undefined;
            inputs["revertToSpot"] = state ? state.revertToSpot : undefined;
            inputs["scalingDownPolicies"] = state ? state.scalingDownPolicies : undefined;
            inputs["scalingTargetPolicies"] = state ? state.scalingTargetPolicies : undefined;
            inputs["scalingUpPolicies"] = state ? state.scalingUpPolicies : undefined;
            inputs["scheduledTasks"] = state ? state.scheduledTasks : undefined;
            inputs["securityGroups"] = state ? state.securityGroups : undefined;
            inputs["shutdownScript"] = state ? state.shutdownScript : undefined;
            inputs["signals"] = state ? state.signals : undefined;
            inputs["spotPercentage"] = state ? state.spotPercentage : undefined;
            inputs["statefulDeallocation"] = state ? state.statefulDeallocation : undefined;
            inputs["subnetIds"] = state ? state.subnetIds : undefined;
            inputs["tags"] = state ? state.tags : undefined;
            inputs["targetGroupArns"] = state ? state.targetGroupArns : undefined;
            inputs["updatePolicy"] = state ? state.updatePolicy : undefined;
            inputs["userData"] = state ? state.userData : undefined;
            inputs["utilizeReservedInstances"] = state ? state.utilizeReservedInstances : undefined;
            inputs["waitForCapacity"] = state ? state.waitForCapacity : undefined;
            inputs["waitForCapacityTimeout"] = state ? state.waitForCapacityTimeout : undefined;
        } else {
            const args = argsOrState as ElastigroupArgs | undefined;
            if (!args || args.fallbackToOndemand === undefined) {
                throw new Error("Missing required property 'fallbackToOndemand'");
            }
            if (!args || args.instanceTypesOndemand === undefined) {
                throw new Error("Missing required property 'instanceTypesOndemand'");
            }
            if (!args || args.instanceTypesSpots === undefined) {
                throw new Error("Missing required property 'instanceTypesSpots'");
            }
            if (!args || args.name === undefined) {
                throw new Error("Missing required property 'name'");
            }
            if (!args || args.orientation === undefined) {
                throw new Error("Missing required property 'orientation'");
            }
            if (!args || args.product === undefined) {
                throw new Error("Missing required property 'product'");
            }
            if (!args || args.securityGroups === undefined) {
                throw new Error("Missing required property 'securityGroups'");
            }
            inputs["availabilityZones"] = args ? args.availabilityZones : undefined;
            inputs["blockDevicesMode"] = args ? args.blockDevicesMode : undefined;
            inputs["capacityUnit"] = args ? args.capacityUnit : undefined;
            inputs["cpuCredits"] = args ? args.cpuCredits : undefined;
            inputs["description"] = args ? args.description : undefined;
            inputs["desiredCapacity"] = args ? args.desiredCapacity : undefined;
            inputs["drainingTimeout"] = args ? args.drainingTimeout : undefined;
            inputs["ebsBlockDevices"] = args ? args.ebsBlockDevices : undefined;
            inputs["ebsOptimized"] = args ? args.ebsOptimized : undefined;
            inputs["elasticIps"] = args ? args.elasticIps : undefined;
            inputs["elasticLoadBalancers"] = args ? args.elasticLoadBalancers : undefined;
            inputs["enableMonitoring"] = args ? args.enableMonitoring : undefined;
            inputs["ephemeralBlockDevices"] = args ? args.ephemeralBlockDevices : undefined;
            inputs["fallbackToOndemand"] = args ? args.fallbackToOndemand : undefined;
            inputs["healthCheckGracePeriod"] = args ? args.healthCheckGracePeriod : undefined;
            inputs["healthCheckType"] = args ? args.healthCheckType : undefined;
            inputs["healthCheckUnhealthyDurationBeforeReplacement"] = args ? args.healthCheckUnhealthyDurationBeforeReplacement : undefined;
            inputs["iamInstanceProfile"] = args ? args.iamInstanceProfile : undefined;
            inputs["imageId"] = args ? args.imageId : undefined;
            inputs["instanceTypesOndemand"] = args ? args.instanceTypesOndemand : undefined;
            inputs["instanceTypesPreferredSpots"] = args ? args.instanceTypesPreferredSpots : undefined;
            inputs["instanceTypesSpots"] = args ? args.instanceTypesSpots : undefined;
            inputs["instanceTypesWeights"] = args ? args.instanceTypesWeights : undefined;
            inputs["integrationBeanstalk"] = args ? args.integrationBeanstalk : undefined;
            inputs["integrationCodedeploy"] = args ? args.integrationCodedeploy : undefined;
            inputs["integrationDockerSwarm"] = args ? args.integrationDockerSwarm : undefined;
            inputs["integrationEcs"] = args ? args.integrationEcs : undefined;
            inputs["integrationGitlab"] = args ? args.integrationGitlab : undefined;
            inputs["integrationKubernetes"] = args ? args.integrationKubernetes : undefined;
            inputs["integrationMesosphere"] = args ? args.integrationMesosphere : undefined;
            inputs["integrationMultaiRuntime"] = args ? args.integrationMultaiRuntime : undefined;
            inputs["integrationNomad"] = args ? args.integrationNomad : undefined;
            inputs["integrationRancher"] = args ? args.integrationRancher : undefined;
            inputs["integrationRoute53"] = args ? args.integrationRoute53 : undefined;
            inputs["keyName"] = args ? args.keyName : undefined;
            inputs["lifetimePeriod"] = args ? args.lifetimePeriod : undefined;
            inputs["maxSize"] = args ? args.maxSize : undefined;
            inputs["minSize"] = args ? args.minSize : undefined;
            inputs["multaiTargetSets"] = args ? args.multaiTargetSets : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["networkInterfaces"] = args ? args.networkInterfaces : undefined;
            inputs["ondemandCount"] = args ? args.ondemandCount : undefined;
            inputs["orientation"] = args ? args.orientation : undefined;
            inputs["persistBlockDevices"] = args ? args.persistBlockDevices : undefined;
            inputs["persistPrivateIp"] = args ? args.persistPrivateIp : undefined;
            inputs["persistRootDevice"] = args ? args.persistRootDevice : undefined;
            inputs["placementTenancy"] = args ? args.placementTenancy : undefined;
            inputs["preferredAvailabilityZones"] = args ? args.preferredAvailabilityZones : undefined;
            inputs["privateIps"] = args ? args.privateIps : undefined;
            inputs["product"] = args ? args.product : undefined;
            inputs["region"] = args ? args.region : undefined;
            inputs["revertToSpot"] = args ? args.revertToSpot : undefined;
            inputs["scalingDownPolicies"] = args ? args.scalingDownPolicies : undefined;
            inputs["scalingTargetPolicies"] = args ? args.scalingTargetPolicies : undefined;
            inputs["scalingUpPolicies"] = args ? args.scalingUpPolicies : undefined;
            inputs["scheduledTasks"] = args ? args.scheduledTasks : undefined;
            inputs["securityGroups"] = args ? args.securityGroups : undefined;
            inputs["shutdownScript"] = args ? args.shutdownScript : undefined;
            inputs["signals"] = args ? args.signals : undefined;
            inputs["spotPercentage"] = args ? args.spotPercentage : undefined;
            inputs["statefulDeallocation"] = args ? args.statefulDeallocation : undefined;
            inputs["subnetIds"] = args ? args.subnetIds : undefined;
            inputs["tags"] = args ? args.tags : undefined;
            inputs["targetGroupArns"] = args ? args.targetGroupArns : undefined;
            inputs["updatePolicy"] = args ? args.updatePolicy : undefined;
            inputs["userData"] = args ? args.userData : undefined;
            inputs["utilizeReservedInstances"] = args ? args.utilizeReservedInstances : undefined;
            inputs["waitForCapacity"] = args ? args.waitForCapacity : undefined;
            inputs["waitForCapacityTimeout"] = args ? args.waitForCapacityTimeout : undefined;
        }
        super("spotinst:aws/elastigroup:Elastigroup", name, inputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering Elastigroup resources.
 */
export interface ElastigroupState {
    readonly availabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    readonly blockDevicesMode?: pulumi.Input<string>;
    readonly capacityUnit?: pulumi.Input<string>;
    readonly cpuCredits?: pulumi.Input<string>;
    readonly description?: pulumi.Input<string>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly drainingTimeout?: pulumi.Input<number>;
    readonly ebsBlockDevices?: pulumi.Input<pulumi.Input<{ deleteOnTermination?: pulumi.Input<boolean>, deviceName: pulumi.Input<string>, encrypted?: pulumi.Input<boolean>, iops?: pulumi.Input<number>, kmsKeyId?: pulumi.Input<string>, snapshotId?: pulumi.Input<string>, volumeSize?: pulumi.Input<number>, volumeType?: pulumi.Input<string> }>[]>;
    readonly ebsOptimized?: pulumi.Input<boolean>;
    readonly elasticIps?: pulumi.Input<pulumi.Input<string>[]>;
    readonly elasticLoadBalancers?: pulumi.Input<pulumi.Input<string>[]>;
    readonly enableMonitoring?: pulumi.Input<boolean>;
    readonly ephemeralBlockDevices?: pulumi.Input<pulumi.Input<{ deviceName: pulumi.Input<string>, virtualName: pulumi.Input<string> }>[]>;
    readonly fallbackToOndemand?: pulumi.Input<boolean>;
    readonly healthCheckGracePeriod?: pulumi.Input<number>;
    readonly healthCheckType?: pulumi.Input<string>;
    readonly healthCheckUnhealthyDurationBeforeReplacement?: pulumi.Input<number>;
    readonly iamInstanceProfile?: pulumi.Input<string>;
    readonly imageId?: pulumi.Input<string>;
    readonly instanceTypesOndemand?: pulumi.Input<string>;
    readonly instanceTypesPreferredSpots?: pulumi.Input<pulumi.Input<string>[]>;
    readonly instanceTypesSpots?: pulumi.Input<pulumi.Input<string>[]>;
    readonly instanceTypesWeights?: pulumi.Input<pulumi.Input<{ instanceType: pulumi.Input<string>, weight: pulumi.Input<number> }>[]>;
    readonly integrationBeanstalk?: pulumi.Input<{ deploymentPreferences?: pulumi.Input<{ automaticRoll?: pulumi.Input<boolean>, batchSizePercentage?: pulumi.Input<number>, gracePeriod?: pulumi.Input<number>, strategy?: pulumi.Input<{ action?: pulumi.Input<string>, shouldDrainInstances?: pulumi.Input<boolean> }> }>, environmentId?: pulumi.Input<string>, managedActions?: pulumi.Input<{ platformUpdate?: pulumi.Input<{ performAt?: pulumi.Input<string>, timeWindow?: pulumi.Input<string>, updateLevel?: pulumi.Input<string> }> }> }>;
    readonly integrationCodedeploy?: pulumi.Input<{ cleanupOnFailure: pulumi.Input<boolean>, deploymentGroups: pulumi.Input<pulumi.Input<{ applicationName: pulumi.Input<string>, deploymentGroupName: pulumi.Input<string> }>[]>, terminateInstanceOnFailure: pulumi.Input<boolean> }>;
    readonly integrationDockerSwarm?: pulumi.Input<{ autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsEnabled?: pulumi.Input<boolean>, masterHost: pulumi.Input<string>, masterPort: pulumi.Input<number> }>;
    readonly integrationEcs?: pulumi.Input<{ autoscaleAttributes?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsAutoConfig?: pulumi.Input<boolean>, autoscaleIsEnabled?: pulumi.Input<boolean>, autoscaleScaleDownNonServiceTasks?: pulumi.Input<boolean>, clusterName: pulumi.Input<string> }>;
    readonly integrationGitlab?: pulumi.Input<{ runner?: pulumi.Input<{ isEnabled?: pulumi.Input<boolean> }> }>;
    readonly integrationKubernetes?: pulumi.Input<{ apiServer?: pulumi.Input<string>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsAutoConfig?: pulumi.Input<boolean>, autoscaleIsEnabled?: pulumi.Input<boolean>, autoscaleLabels?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, clusterIdentifier?: pulumi.Input<string>, integrationMode?: pulumi.Input<string>, token?: pulumi.Input<string> }>;
    readonly integrationMesosphere?: pulumi.Input<{ apiServer: pulumi.Input<string> }>;
    readonly integrationMultaiRuntime?: pulumi.Input<{ deploymentId: pulumi.Input<string> }>;
    readonly integrationNomad?: pulumi.Input<{ aclToken?: pulumi.Input<string>, autoscaleConstraints?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsEnabled?: pulumi.Input<boolean>, masterHost: pulumi.Input<string>, masterPort: pulumi.Input<number> }>;
    readonly integrationRancher?: pulumi.Input<{ accessKey: pulumi.Input<string>, masterHost: pulumi.Input<string>, secretKey: pulumi.Input<string>, version?: pulumi.Input<string> }>;
    readonly integrationRoute53?: pulumi.Input<{ domains: pulumi.Input<pulumi.Input<{ hostedZoneId: pulumi.Input<string>, recordSets: pulumi.Input<pulumi.Input<{ name: pulumi.Input<string>, usePublicIp?: pulumi.Input<boolean> }>[]> }>[]> }>;
    readonly keyName?: pulumi.Input<string>;
    readonly lifetimePeriod?: pulumi.Input<string>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly multaiTargetSets?: pulumi.Input<pulumi.Input<{ balancerId: pulumi.Input<string>, targetSetId: pulumi.Input<string> }>[]>;
    readonly name?: pulumi.Input<string>;
    readonly networkInterfaces?: pulumi.Input<pulumi.Input<{ associateIpv6Address?: pulumi.Input<boolean>, associatePublicIpAddress?: pulumi.Input<boolean>, deleteOnTermination?: pulumi.Input<boolean>, description?: pulumi.Input<string>, deviceIndex: pulumi.Input<string>, networkInterfaceId?: pulumi.Input<string>, privateIpAddress?: pulumi.Input<string>, secondaryPrivateIpAddressCount?: pulumi.Input<string> }>[]>;
    readonly ondemandCount?: pulumi.Input<number>;
    readonly orientation?: pulumi.Input<string>;
    readonly persistBlockDevices?: pulumi.Input<boolean>;
    readonly persistPrivateIp?: pulumi.Input<boolean>;
    readonly persistRootDevice?: pulumi.Input<boolean>;
    readonly placementTenancy?: pulumi.Input<string>;
    readonly preferredAvailabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    readonly privateIps?: pulumi.Input<pulumi.Input<string>[]>;
    readonly product?: pulumi.Input<string>;
    readonly region?: pulumi.Input<string>;
    readonly revertToSpot?: pulumi.Input<{ performAt: pulumi.Input<string>, timeWindows?: pulumi.Input<pulumi.Input<string>[]> }>;
    readonly scalingDownPolicies?: pulumi.Input<pulumi.Input<{ actionType?: pulumi.Input<string>, adjustment?: pulumi.Input<string>, cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, evaluationPeriods?: pulumi.Input<number>, isEnabled?: pulumi.Input<boolean>, maxTargetCapacity?: pulumi.Input<string>, maximum?: pulumi.Input<string>, metricName: pulumi.Input<string>, minTargetCapacity?: pulumi.Input<string>, minimum?: pulumi.Input<string>, namespace: pulumi.Input<string>, operator?: pulumi.Input<string>, period?: pulumi.Input<number>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target?: pulumi.Input<string>, threshold: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scalingTargetPolicies?: pulumi.Input<pulumi.Input<{ cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, metricName: pulumi.Input<string>, namespace: pulumi.Input<string>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scalingUpPolicies?: pulumi.Input<pulumi.Input<{ actionType?: pulumi.Input<string>, adjustment?: pulumi.Input<string>, cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, evaluationPeriods?: pulumi.Input<number>, isEnabled?: pulumi.Input<boolean>, maxTargetCapacity?: pulumi.Input<string>, maximum?: pulumi.Input<string>, metricName: pulumi.Input<string>, minTargetCapacity?: pulumi.Input<string>, minimum?: pulumi.Input<string>, namespace: pulumi.Input<string>, operator?: pulumi.Input<string>, period?: pulumi.Input<number>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target?: pulumi.Input<string>, threshold: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scheduledTasks?: pulumi.Input<pulumi.Input<{ adjustment?: pulumi.Input<string>, adjustmentPercentage?: pulumi.Input<string>, batchSizePercentage?: pulumi.Input<string>, cronExpression?: pulumi.Input<string>, frequency?: pulumi.Input<string>, gracePeriod?: pulumi.Input<string>, isEnabled?: pulumi.Input<boolean>, maxCapacity?: pulumi.Input<string>, minCapacity?: pulumi.Input<string>, scaleMaxCapacity?: pulumi.Input<string>, scaleMinCapacity?: pulumi.Input<string>, scaleTargetCapacity?: pulumi.Input<string>, startTime?: pulumi.Input<string>, targetCapacity?: pulumi.Input<string>, taskType: pulumi.Input<string> }>[]>;
    readonly securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    readonly shutdownScript?: pulumi.Input<string>;
    readonly signals?: pulumi.Input<pulumi.Input<{ name: pulumi.Input<string>, timeout?: pulumi.Input<number> }>[]>;
    readonly spotPercentage?: pulumi.Input<number>;
    readonly statefulDeallocation?: pulumi.Input<{ shouldDeleteImages?: pulumi.Input<boolean>, shouldDeleteNetworkInterfaces?: pulumi.Input<boolean>, shouldDeleteSnapshots?: pulumi.Input<boolean>, shouldDeleteVolumes?: pulumi.Input<boolean> }>;
    readonly subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly tags?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>;
    readonly targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    readonly updatePolicy?: pulumi.Input<{ autoApplyTags?: pulumi.Input<boolean>, rollConfig?: pulumi.Input<{ batchSizePercentage: pulumi.Input<number>, gracePeriod?: pulumi.Input<number>, healthCheckType?: pulumi.Input<string>, waitForRollPercentage?: pulumi.Input<number>, waitForRollTimeout?: pulumi.Input<number> }>, shouldResumeStateful: pulumi.Input<boolean>, shouldRoll: pulumi.Input<boolean>, waitForRollPercentage?: pulumi.Input<number>, waitForRollTimeout?: pulumi.Input<number> }>;
    readonly userData?: pulumi.Input<string>;
    readonly utilizeReservedInstances?: pulumi.Input<boolean>;
    readonly waitForCapacity?: pulumi.Input<number>;
    readonly waitForCapacityTimeout?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a Elastigroup resource.
 */
export interface ElastigroupArgs {
    readonly availabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    readonly blockDevicesMode?: pulumi.Input<string>;
    readonly capacityUnit?: pulumi.Input<string>;
    readonly cpuCredits?: pulumi.Input<string>;
    readonly description?: pulumi.Input<string>;
    readonly desiredCapacity?: pulumi.Input<number>;
    readonly drainingTimeout?: pulumi.Input<number>;
    readonly ebsBlockDevices?: pulumi.Input<pulumi.Input<{ deleteOnTermination?: pulumi.Input<boolean>, deviceName: pulumi.Input<string>, encrypted?: pulumi.Input<boolean>, iops?: pulumi.Input<number>, kmsKeyId?: pulumi.Input<string>, snapshotId?: pulumi.Input<string>, volumeSize?: pulumi.Input<number>, volumeType?: pulumi.Input<string> }>[]>;
    readonly ebsOptimized?: pulumi.Input<boolean>;
    readonly elasticIps?: pulumi.Input<pulumi.Input<string>[]>;
    readonly elasticLoadBalancers?: pulumi.Input<pulumi.Input<string>[]>;
    readonly enableMonitoring?: pulumi.Input<boolean>;
    readonly ephemeralBlockDevices?: pulumi.Input<pulumi.Input<{ deviceName: pulumi.Input<string>, virtualName: pulumi.Input<string> }>[]>;
    readonly fallbackToOndemand: pulumi.Input<boolean>;
    readonly healthCheckGracePeriod?: pulumi.Input<number>;
    readonly healthCheckType?: pulumi.Input<string>;
    readonly healthCheckUnhealthyDurationBeforeReplacement?: pulumi.Input<number>;
    readonly iamInstanceProfile?: pulumi.Input<string>;
    readonly imageId?: pulumi.Input<string>;
    readonly instanceTypesOndemand: pulumi.Input<string>;
    readonly instanceTypesPreferredSpots?: pulumi.Input<pulumi.Input<string>[]>;
    readonly instanceTypesSpots: pulumi.Input<pulumi.Input<string>[]>;
    readonly instanceTypesWeights?: pulumi.Input<pulumi.Input<{ instanceType: pulumi.Input<string>, weight: pulumi.Input<number> }>[]>;
    readonly integrationBeanstalk?: pulumi.Input<{ deploymentPreferences?: pulumi.Input<{ automaticRoll?: pulumi.Input<boolean>, batchSizePercentage?: pulumi.Input<number>, gracePeriod?: pulumi.Input<number>, strategy?: pulumi.Input<{ action?: pulumi.Input<string>, shouldDrainInstances?: pulumi.Input<boolean> }> }>, environmentId?: pulumi.Input<string>, managedActions?: pulumi.Input<{ platformUpdate?: pulumi.Input<{ performAt?: pulumi.Input<string>, timeWindow?: pulumi.Input<string>, updateLevel?: pulumi.Input<string> }> }> }>;
    readonly integrationCodedeploy?: pulumi.Input<{ cleanupOnFailure: pulumi.Input<boolean>, deploymentGroups: pulumi.Input<pulumi.Input<{ applicationName: pulumi.Input<string>, deploymentGroupName: pulumi.Input<string> }>[]>, terminateInstanceOnFailure: pulumi.Input<boolean> }>;
    readonly integrationDockerSwarm?: pulumi.Input<{ autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsEnabled?: pulumi.Input<boolean>, masterHost: pulumi.Input<string>, masterPort: pulumi.Input<number> }>;
    readonly integrationEcs?: pulumi.Input<{ autoscaleAttributes?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsAutoConfig?: pulumi.Input<boolean>, autoscaleIsEnabled?: pulumi.Input<boolean>, autoscaleScaleDownNonServiceTasks?: pulumi.Input<boolean>, clusterName: pulumi.Input<string> }>;
    readonly integrationGitlab?: pulumi.Input<{ runner?: pulumi.Input<{ isEnabled?: pulumi.Input<boolean> }> }>;
    readonly integrationKubernetes?: pulumi.Input<{ apiServer?: pulumi.Input<string>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsAutoConfig?: pulumi.Input<boolean>, autoscaleIsEnabled?: pulumi.Input<boolean>, autoscaleLabels?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, clusterIdentifier?: pulumi.Input<string>, integrationMode?: pulumi.Input<string>, token?: pulumi.Input<string> }>;
    readonly integrationMesosphere?: pulumi.Input<{ apiServer: pulumi.Input<string> }>;
    readonly integrationMultaiRuntime?: pulumi.Input<{ deploymentId: pulumi.Input<string> }>;
    readonly integrationNomad?: pulumi.Input<{ aclToken?: pulumi.Input<string>, autoscaleConstraints?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>, autoscaleCooldown?: pulumi.Input<number>, autoscaleDown?: pulumi.Input<{ evaluationPeriods?: pulumi.Input<number> }>, autoscaleHeadroom?: pulumi.Input<{ cpuPerUnit?: pulumi.Input<number>, memoryPerUnit?: pulumi.Input<number>, numOfUnits?: pulumi.Input<number> }>, autoscaleIsEnabled?: pulumi.Input<boolean>, masterHost: pulumi.Input<string>, masterPort: pulumi.Input<number> }>;
    readonly integrationRancher?: pulumi.Input<{ accessKey: pulumi.Input<string>, masterHost: pulumi.Input<string>, secretKey: pulumi.Input<string>, version?: pulumi.Input<string> }>;
    readonly integrationRoute53?: pulumi.Input<{ domains: pulumi.Input<pulumi.Input<{ hostedZoneId: pulumi.Input<string>, recordSets: pulumi.Input<pulumi.Input<{ name: pulumi.Input<string>, usePublicIp?: pulumi.Input<boolean> }>[]> }>[]> }>;
    readonly keyName?: pulumi.Input<string>;
    readonly lifetimePeriod?: pulumi.Input<string>;
    readonly maxSize?: pulumi.Input<number>;
    readonly minSize?: pulumi.Input<number>;
    readonly multaiTargetSets?: pulumi.Input<pulumi.Input<{ balancerId: pulumi.Input<string>, targetSetId: pulumi.Input<string> }>[]>;
    readonly name: pulumi.Input<string>;
    readonly networkInterfaces?: pulumi.Input<pulumi.Input<{ associateIpv6Address?: pulumi.Input<boolean>, associatePublicIpAddress?: pulumi.Input<boolean>, deleteOnTermination?: pulumi.Input<boolean>, description?: pulumi.Input<string>, deviceIndex: pulumi.Input<string>, networkInterfaceId?: pulumi.Input<string>, privateIpAddress?: pulumi.Input<string>, secondaryPrivateIpAddressCount?: pulumi.Input<string> }>[]>;
    readonly ondemandCount?: pulumi.Input<number>;
    readonly orientation: pulumi.Input<string>;
    readonly persistBlockDevices?: pulumi.Input<boolean>;
    readonly persistPrivateIp?: pulumi.Input<boolean>;
    readonly persistRootDevice?: pulumi.Input<boolean>;
    readonly placementTenancy?: pulumi.Input<string>;
    readonly preferredAvailabilityZones?: pulumi.Input<pulumi.Input<string>[]>;
    readonly privateIps?: pulumi.Input<pulumi.Input<string>[]>;
    readonly product: pulumi.Input<string>;
    readonly region?: pulumi.Input<string>;
    readonly revertToSpot?: pulumi.Input<{ performAt: pulumi.Input<string>, timeWindows?: pulumi.Input<pulumi.Input<string>[]> }>;
    readonly scalingDownPolicies?: pulumi.Input<pulumi.Input<{ actionType?: pulumi.Input<string>, adjustment?: pulumi.Input<string>, cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, evaluationPeriods?: pulumi.Input<number>, isEnabled?: pulumi.Input<boolean>, maxTargetCapacity?: pulumi.Input<string>, maximum?: pulumi.Input<string>, metricName: pulumi.Input<string>, minTargetCapacity?: pulumi.Input<string>, minimum?: pulumi.Input<string>, namespace: pulumi.Input<string>, operator?: pulumi.Input<string>, period?: pulumi.Input<number>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target?: pulumi.Input<string>, threshold: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scalingTargetPolicies?: pulumi.Input<pulumi.Input<{ cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, metricName: pulumi.Input<string>, namespace: pulumi.Input<string>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scalingUpPolicies?: pulumi.Input<pulumi.Input<{ actionType?: pulumi.Input<string>, adjustment?: pulumi.Input<string>, cooldown?: pulumi.Input<number>, dimensions?: pulumi.Input<{[key: string]: any}>, evaluationPeriods?: pulumi.Input<number>, isEnabled?: pulumi.Input<boolean>, maxTargetCapacity?: pulumi.Input<string>, maximum?: pulumi.Input<string>, metricName: pulumi.Input<string>, minTargetCapacity?: pulumi.Input<string>, minimum?: pulumi.Input<string>, namespace: pulumi.Input<string>, operator?: pulumi.Input<string>, period?: pulumi.Input<number>, policyName: pulumi.Input<string>, source?: pulumi.Input<string>, statistic?: pulumi.Input<string>, target?: pulumi.Input<string>, threshold: pulumi.Input<number>, unit: pulumi.Input<string> }>[]>;
    readonly scheduledTasks?: pulumi.Input<pulumi.Input<{ adjustment?: pulumi.Input<string>, adjustmentPercentage?: pulumi.Input<string>, batchSizePercentage?: pulumi.Input<string>, cronExpression?: pulumi.Input<string>, frequency?: pulumi.Input<string>, gracePeriod?: pulumi.Input<string>, isEnabled?: pulumi.Input<boolean>, maxCapacity?: pulumi.Input<string>, minCapacity?: pulumi.Input<string>, scaleMaxCapacity?: pulumi.Input<string>, scaleMinCapacity?: pulumi.Input<string>, scaleTargetCapacity?: pulumi.Input<string>, startTime?: pulumi.Input<string>, targetCapacity?: pulumi.Input<string>, taskType: pulumi.Input<string> }>[]>;
    readonly securityGroups: pulumi.Input<pulumi.Input<string>[]>;
    readonly shutdownScript?: pulumi.Input<string>;
    readonly signals?: pulumi.Input<pulumi.Input<{ name: pulumi.Input<string>, timeout?: pulumi.Input<number> }>[]>;
    readonly spotPercentage?: pulumi.Input<number>;
    readonly statefulDeallocation?: pulumi.Input<{ shouldDeleteImages?: pulumi.Input<boolean>, shouldDeleteNetworkInterfaces?: pulumi.Input<boolean>, shouldDeleteSnapshots?: pulumi.Input<boolean>, shouldDeleteVolumes?: pulumi.Input<boolean> }>;
    readonly subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    readonly tags?: pulumi.Input<pulumi.Input<{ key: pulumi.Input<string>, value: pulumi.Input<string> }>[]>;
    readonly targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    readonly updatePolicy?: pulumi.Input<{ autoApplyTags?: pulumi.Input<boolean>, rollConfig?: pulumi.Input<{ batchSizePercentage: pulumi.Input<number>, gracePeriod?: pulumi.Input<number>, healthCheckType?: pulumi.Input<string>, waitForRollPercentage?: pulumi.Input<number>, waitForRollTimeout?: pulumi.Input<number> }>, shouldResumeStateful: pulumi.Input<boolean>, shouldRoll: pulumi.Input<boolean>, waitForRollPercentage?: pulumi.Input<number>, waitForRollTimeout?: pulumi.Input<number> }>;
    readonly userData?: pulumi.Input<string>;
    readonly utilizeReservedInstances?: pulumi.Input<boolean>;
    readonly waitForCapacity?: pulumi.Input<number>;
    readonly waitForCapacityTimeout?: pulumi.Input<number>;
}
